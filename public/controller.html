<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Billiard Controller</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            background: #0d2818;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
        }

        /* Minimal UI - small score in corner */
        #my-score {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
        }

        #cooldown-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
            margin-right: 8px;
            vertical-align: middle;
        }

        #cooldown-dot.ready {
            background: #2ecc71;
            box-shadow: 0 0 8px #2ecc71;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <div id="my-score">
        <span id="cooldown-dot"></span>
        <span id="score-value">0 pts</span>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreValueEl = document.getElementById('score-value');
        const cooldownDot = document.getElementById('cooldown-dot');

        let gameState = { balls: [], players: {} };
        let myId = null;
        let isReady = false;

        // Input State
        let dragStart = null;
        let dragCurrent = null;

        // Table dimensions
        const TABLE_WIDTH = 1600;
        const TABLE_HEIGHT = 900;

        // Socket events
        socket.on('connect', () => {
            console.log("Connected to server");
            socket.emit('autoJoin');
        });

        socket.on('init', (data) => {
            myId = data.id;
        });

        socket.on('gameState', (state) => {
            gameState = state;
            updateUI(state);
        });

        function updateUI(state) {
            if (!myId) return;
            const me = state.players[myId];
            if (me) {
                scoreValueEl.textContent = me.score + ' pts';
                if (me.cooldownProgress <= 0) {
                    if (!isReady) {
                        cooldownDot.classList.add('ready');
                        isReady = true;
                    }
                } else {
                    if (isReady) {
                        cooldownDot.classList.remove('ready');
                        isReady = false;
                    }
                }
            }
        }

        // Canvas & Input
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        canvas.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            dragStart = { x: e.clientX, y: e.clientY };
            dragCurrent = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('pointermove', (e) => {
            e.preventDefault();
            if (!dragStart) return;
            dragCurrent = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (!dragStart) return;

            const dx = dragStart.x - dragCurrent.x;
            const dy = dragStart.y - dragCurrent.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDrag = 300;

            if (dist > 15 && isReady) {
                const angle = Math.atan2(dy, dx);
                const force = Math.min(dist, maxDrag) / maxDrag;
                socket.emit('shoot', { angle, force });

                isReady = false;
                cooldownDot.classList.remove('ready');

                if (navigator.vibrate) navigator.vibrate(50);
            }

            dragStart = null;
            dragCurrent = null;
        });

        canvas.addEventListener('pointercancel', () => {
            dragStart = null;
            dragCurrent = null;
        });

        // Rendering
        function render() {
            requestAnimationFrame(render);

            // Full table view
            const scale = Math.min(canvas.width / TABLE_WIDTH, canvas.height / TABLE_HEIGHT) * 0.98;
            const offsetX = (canvas.width - TABLE_WIDTH * scale) / 2;
            const offsetY = (canvas.height - TABLE_HEIGHT * scale) / 2;

            // Background
            ctx.fillStyle = '#0d2818';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Table frame shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(-45, -45, TABLE_WIDTH + 90, TABLE_HEIGHT + 90);
            ctx.shadowBlur = 0;

            // Rails
            const railWidth = 40;
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(-railWidth, -railWidth, TABLE_WIDTH + 2 * railWidth, railWidth);
            ctx.fillRect(-railWidth, TABLE_HEIGHT, TABLE_WIDTH + 2 * railWidth, railWidth);
            ctx.fillRect(-railWidth, 0, railWidth, TABLE_HEIGHT);
            ctx.fillRect(TABLE_WIDTH, 0, railWidth, TABLE_HEIGHT);

            // Table surface
            const feltGradient = ctx.createRadialGradient(
                TABLE_WIDTH / 2, TABLE_HEIGHT / 2, 0,
                TABLE_WIDTH / 2, TABLE_HEIGHT / 2, TABLE_WIDTH / 1.5
            );
            feltGradient.addColorStop(0, '#1e8449');
            feltGradient.addColorStop(1, '#145a32');
            ctx.fillStyle = feltGradient;
            ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            // Cushion
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 10;
            ctx.strokeRect(5, 5, TABLE_WIDTH - 10, TABLE_HEIGHT - 10);

            // Holes
            const holes = [
                [0, 0], [TABLE_WIDTH / 2, 0], [TABLE_WIDTH, 0],
                [0, TABLE_HEIGHT], [TABLE_WIDTH / 2, TABLE_HEIGHT], [TABLE_WIDTH, TABLE_HEIGHT]
            ];
            const holeRadius = 45;

            holes.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos[0], pos[1], holeRadius + 8, 0, Math.PI * 2);
                ctx.fillStyle = '#3e2723';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(pos[0], pos[1], holeRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#0a0a0a';
                ctx.fill();
            });

            // Find my ball
            let myBall = null;
            if (myId) {
                myBall = gameState.balls.find(b => b.playerId === myId);
            }

            // Draw all balls
            gameState.balls.forEach(ball => {
                // Shadow
                ctx.beginPath();
                ctx.arc(ball.x + 4, ball.y + 4, ball.r, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();

                // Ball with 3D effect
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);

                const ballGradient = ctx.createRadialGradient(
                    ball.x - ball.r * 0.3, ball.y - ball.r * 0.3, ball.r * 0.1,
                    ball.x, ball.y, ball.r
                );

                if (ball.label === 'BlackBall') {
                    ballGradient.addColorStop(0, '#444');
                    ballGradient.addColorStop(1, '#000');
                } else if (ball.label === 'PlayerBall') {
                    ballGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
                    ballGradient.addColorStop(0.3, ball.color || 'hsl(0,70%,50%)');
                    ballGradient.addColorStop(1, ball.color || 'hsl(0,70%,50%)');
                } else {
                    ballGradient.addColorStop(0, 'white');
                    ballGradient.addColorStop(0.5, ball.color || 'white');
                    ballGradient.addColorStop(1, ball.color || 'white');
                }

                ctx.fillStyle = ballGradient;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Highlight my ball
                if (myBall && ball.id === myBall.id) {
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.r + 6, 0, Math.PI * 2);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Pulsing glow
                    const glow = 0.3 + 0.2 * Math.sin(Date.now() / 200);
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.r + 12, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255,255,255,${glow})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Player name & score labels
                if (ball.label === 'PlayerBall' && ball.playerId) {
                    const player = gameState.players[ball.playerId];
                    if (player) {
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 14px Segoe UI, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = 'rgba(0,0,0,0.8)';
                        ctx.shadowBlur = 3;
                        ctx.fillText(player.name, ball.x, ball.y - ball.r - 18);

                        ctx.font = '12px Segoe UI, sans-serif';
                        ctx.fillStyle = player.score >= 0 ? '#2ecc71' : '#e74c3c';
                        ctx.fillText(`${player.score} pts`, ball.x, ball.y - ball.r - 5);
                        ctx.shadowBlur = 0;

                        // Cooldown ring
                        if (player.cooldownProgress > 0) {
                            ctx.beginPath();
                            ctx.arc(ball.x, ball.y, ball.r + 5, -Math.PI / 2,
                                -Math.PI / 2 + Math.PI * 2 * (1 - player.cooldownProgress));
                            ctx.strokeStyle = 'rgba(46,204,113,0.8)';
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }
                    }
                }

                // Shine
                ctx.beginPath();
                ctx.arc(ball.x - ball.r * 0.3, ball.y - ball.r * 0.3, ball.r * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fill();
            });

            // Aiming arrow
            if (dragStart && dragCurrent && myBall && isReady) {
                const dx = dragStart.x - dragCurrent.x;
                const dy = dragStart.y - dragCurrent.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const maxDrag = 300;
                const force = Math.min(dist, maxDrag) / maxDrag;

                if (dist > 15) {
                    const arrowLen = 50 + force * 300;
                    const endX = myBall.x + Math.cos(angle) * arrowLen;
                    const endY = myBall.y + Math.sin(angle) * arrowLen;

                    // Arrow color based on power
                    let color = force < 0.33 ? 'rgba(46,204,113,0.9)' :
                        force < 0.66 ? 'rgba(241,196,15,0.9)' :
                            'rgba(231,76,60,0.9)';

                    ctx.shadowColor = 'rgba(255,255,255,0.5)';
                    ctx.shadowBlur = 10;

                    ctx.beginPath();
                    ctx.moveTo(myBall.x, myBall.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 6 + force * 6;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    ctx.shadowBlur = 0;

                    // Arrow head
                    const headLen = 20 + force * 20;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - headLen * Math.cos(angle - 0.4), endY - headLen * Math.sin(angle - 0.4));
                    ctx.lineTo(endX - headLen * Math.cos(angle + 0.4), endY - headLen * Math.sin(angle + 0.4));
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();

                    // Trajectory dots
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    for (let i = 1; i <= 4; i++) {
                        const dotX = myBall.x + Math.cos(angle) * (arrowLen + 25 * i);
                        const dotY = myBall.y + Math.sin(angle) * (arrowLen + 25 * i);
                        if (dotX > 0 && dotX < TABLE_WIDTH && dotY > 0 && dotY < TABLE_HEIGHT) {
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            ctx.restore();
        }

        render();
    </script>
</body>

</html>